### Multi-class Classification to train ML program, using the simulations generated by simulate_mark2.sh

 
# imports

import os 
import gzip
import _pickle as pickle

import numpy as np
import scipy.stats

import skimage.transform
from keras import models, layers, activations, optimizers, regularizers
from keras.utils import plot_model
from keras.models import load_model
from keras import backend as K

import matplotlib.pyplot as plt
from sklearn.metrics import confusion_matrix
import pymc3 # this will be removed
import pydot # optional
from sklearn import svm, datasets
from sklearn.model_selection import train_test_split
from sklearn.utils.multiclass import unique_labels

import itertools

import ImaGene

exec(open('/Users/nathanrobins/Documents/UG_proj/ImaGene/ImaGene.py').read())

# read the simulations from simulate.sh & store them into objects

# DOUBLE CHECK THE FILE & MODEL NAME
myfile = ImaFile(simulations_folder='/Users/nathanrobins/Documents/UG_proj/simdata17.05.1', nr_samples=128, model_name='Marth-3epoch-CEU')

# USE A V LOW NO OF REPLICATES JUST TO CHECK THAT THE PIPELINE WORKS
mygene = myfile.read_simulations(parameter_name='selection_coeff_hetero', max_nrepl=100)

# look at the allele frequency
#mygene.summary()

#freqs = calculate_allele_frequency(mygene, ? )
## ? should be exactly where the allele of choice is
#plt.scatter(mygene.targets, freqs, marker='o')
#plt.xlabel('Target')
#plt.ylabel('Allele frequency')

# manipulate the object - INCLUDING CHANGE THE SIZE TO 128 BY 128 (DUE TO THE NUMBER OF CHROM IN SIMULATE/SH BEING 128)
mygene.majorminor()
# remove alleese with low freq = 
mygene.filter_freq(0.01)
mygene.sort('rows_freq')
mygene.sort('cols_freq')
mygene.resize((128, 128))
mygene.convert()

#define the multiclasses that we will carry out, shuffle images and convert them ready for keras
mygene.classes = np.array([0,100,200,300,400])
#len(get_index_classes(mygene.targets, mygene.classes))
mygene.subset(get_index_classes(mygene.targets, mygene.classes))
#mygene.summary 
#randomly shuffle the images
mygene.subset(get_index_random(mygene))

mygene.targets = to_categorical(mygene.targets)


# plot one image / class
#for sel in mygene.classes:
#    print(sel)
    #mygene.plot(np.where(mygene.targets == sel)[0][0])
#mygene.summary()



# data is now classification ready --> save it
#mygene.save(file='mygene')

# to load:
#mygene = load_imagene(file='mygene')

# Build the keras model
model = models.Sequential([
                layers.Conv2D(filters=32, kernel_size=(3,3), strides=(1,1), activation='relu', kernel_regularizer=regularizers.l1_l2(l1=0.005, l2=0.005), padding='valid', input_shape=mygene.data.shape[1:4]),
                layers.MaxPooling2D(pool_size=(2,2)),
                layers.Conv2D(filters=64, kernel_size=(3,3), strides=(1,1), activation='relu', kernel_regularizer=regularizers.l1_l2(l1=0.005, l2=0.005), padding='valid'),
                layers.MaxPooling2D(pool_size=(2,2)),
                layers.Conv2D(filters=64, kernel_size=(3,3), strides=(1,1), activation='relu', kernel_regularizer=regularizers.l1_l2(l1=0.005, l2=0.005), padding='valid'),
                layers.MaxPooling2D(pool_size=(2,2)),
                layers.Flatten(),
                layers.Dense(units=len(mygene.classes), activation='softmax')])

model.compile(optimizer='adam',
			  loss='categorical_crossentropy',
			  metrics=['accuracy'])                    

#initialise the network object
mynet = ImaNet(name='[C32+P]+[C64+P]x2')

# summarise the model
model.summary()
#plot_model(model, 'net.png')


print(1)
# train the model
score = model.fit(mygene.data, mygene.targets, batch_size=32, epochs=3, verbose=0, validation_split=0.10)

#model.save('net.h5')

#update scores
mynet.update_scores(score)


#repeat the procedure for training for all iterations
i = 2
while i < 5:

    print(i)
    
    myfile = ImaFile(simulations_folder='/Users/nathanrobins/Documents/UG_proj/simdata17.05.' + str(i), nr_samples=128, model_name='Marth-3epoch-CEU')
    mygene = myfile.read_simulations(parameter_name='selection_coeff_hetero', max_nrepl=100)

    mygene.majorminor()
    mygene.filter_freq(0.01)
    mygene.sort('rows_freq')
    mygene.sort('cols_freq')
    mygene.resize((128, 128))
    mygene.convert()

    mygene.classes = np.array([0,100,200,300,400])
    mygene.subset(get_index_classes(mygene.targets, mygene.classes))
    mygene.subset(get_index_random(mygene))

    mygene.targets = to_categorical(mygene.targets)
    
    model = load_model('net.h5')
    
    score = model.fit(mygene.data, mygene.targets, batch_size=32, epochs=3, verbose=0, validation_split=0.10)
    mynet.update_scores(score)
    
    model.save('net.h5')
    
    i += 1


# plot the training 
mynet.plot_train()

# save and/or load final model

model.save('net.h5')

model = load_model('net.h5')

# evaluate the last training on testing set

i = 5
myfile = ImaFile(simulations_folder='/Users/nathanrobins/Documents/UG_proj/simdata17.05.' + str(i), nr_samples=128, model_name='Marth-3epoch-CEU')
mygene_test = myfile.read_simulations(parameter_name='selection_coeff_hetero', max_nrepl=100)

mygene_test.majorminor()
mygene_test.filter_freq(0.01)
mygene_test.sort('rows_freq')
mygene_test.sort('cols_freq')
mygene_test.resize((128, 128))
mygene_test.convert()

mygene_test.classes = np.array([0,100,200,300,400])
classes_idx = get_index_classes(mygene_test.targets, mygene_test.classes)
mygene_test.subset(classes_idx)
rnd_idx = get_index_random(mygene_test)
mygene_test.subset(rnd_idx)

mygene_test.targets = to_categorical(mygene_test.targets)

mynet.test = model.evaluate(mygene_test.data, mygene_test.targets, batch_size=None, verbose=0)
print(mynet.test)

# plot a confusion matrix & scatter plot

mynet.predict(mygene_test, model)
mynet.values.shape

mynet.plot_cm(mygene_test.classes)

#plot_confusion_matrix(mygene_test.data, mygene_test.targets, mygene_test.classes)

#mynet.plot_scatter()