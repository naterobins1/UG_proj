### Multi-class Classification to train ML program, using the simulations generated by simulate_mark2.sh

 
# imports

import os 
import gzip
import _pickle as pickle

import numpy as np
import scipy.stats

import skimage.transform
from keras import models, layers, activations, optimizers, regularizers
from keras.utils import plot_model
from keras.models import load_model
from keras import backend as K

import matplotlib.pyplot as plt
from sklearn.metrics import confusion_matrix
#import pymc3 # this will be removed
import pydot # optional
from sklearn import svm, datasets
from sklearn.model_selection import train_test_split
from sklearn.utils.multiclass import unique_labels

import itertools

#import ImaGene

exec(open('/home/nathanrobins/UG_proj/ImaGene/ImaGene.py').read())

# read the simulations from simulate.sh & store them into objects
folders = 10
i = 1 
while i<=folders:
    myfile = ImaFile(simulations_folder='/home/nathanrobins/UG_proj/code/simulation.Multi.'+str(i), nr_samples=128, model_name='Marth-3epoch-CEU')
    mygene = myfile.read_simulations(parameter_name='selection_coeff_hetero', max_nrepl=5000)

# look at the allele frequency
    mygene.summary()

    if i ==1:
        freqs = calculate_allele_frequency(mygene, 0.02)
        #plt.scatter(mygene.targets, freqs, marker='o')
        #plt.xlabel('Target')
        #plt.ylabel('Allele frequency')
        #plt.show()
        #plt.clf()

# manipulate the object - INCLUDING CHANGE THE SIZE TO 128 BY 128 (DUE TO THE NUMBER OF CHROM IN SIMULATE/SH BEING 128)
    #mygene.majorminor()
# remove alleese with low freq = 
    mygene.filter_freq(0.01)
    mygene.sort('rows_freq')
    mygene.sort('cols_freq')
    mygene.resize((128, 128))
    mygene.convert()

#define the multiclasses that we will carry out, shuffle images and convert them ready for keras
    mygene.set_classes = np.array([0,100,200,300,400])
#len(get_index_classes(mygene.targets, mygene.classes))
    if i ==1:
        for sel in mygene.classes:
            print(sel)
            #mygene.plot(np.where(mygene.targets == sel)[0][0])
        mygene.summary()

    #mygene.targets = to_categorical(mygene.targets)
    #mygene.subset(get_index_classes(mygene.targets, mygene.classes))
    #mygene.summary 
#randomly shuffle the images
    mygene.subset(get_index_random(mygene))

    mygene.targets = to_categorical(mygene.targets)

    #mygene.subset(get_index_classes(mygene.targets, mygene.classes))
    #mygene.summary 
#randomly shuffle the images
#    mygene.subset(get_index_random(mygene))



# data is now classification ready --> save it
#mygene.save(file='mygene')

# to load:
#mygene = load_imagene(file='mygene')
    
    #first iteration
    if i==1:

        # Build the keras model
        model = models.Sequential([
                layers.Conv2D(filters=32, kernel_size=(3,3), strides=(1,1), activation='relu', kernel_regularizer=regularizers.l1_l2(l1=0.005, l2=0.005), padding='valid', input_shape=mygene.data.shape[1:4]),
                layers.MaxPooling2D(pool_size=(2,2)),
                layers.Conv2D(filters=64, kernel_size=(3,3), strides=(1,1), activation='relu', kernel_regularizer=regularizers.l1_l2(l1=0.005, l2=0.005), padding='valid'),
                layers.MaxPooling2D(pool_size=(2,2)),
                layers.Conv2D(filters=64, kernel_size=(3,3), strides=(1,1), activation='relu', kernel_regularizer=regularizers.l1_l2(l1=0.005, l2=0.005), padding='valid'),
                layers.MaxPooling2D(pool_size=(2,2)),
                layers.Flatten(),
                #layers.Dense(units=64, activation='relu'), 
                #layers.Dense(units=64, activation='relu'),
                layers.Dense(units=len(mygene.classes), activation='softmax')])
                #layers.Dense(units=1, activation='softmax')])

        model.compile(optimizer='rmsprop',
			  loss='categorical_crossentropy',
			  metrics=['accuracy'])                    

        #initialise the network object
        mynet = ImaNet(name='[C32+P]+[C64+P]x2')

        # summarise the model
        model.summary()
        #plot_model(model, 'net.png')
    #train the model
    if i <folders:
        print(i)
        score = model.fit(mygene.data, mygene.targets, batch_size=32, epochs=10, verbose=1, validation_split=0.10)
        #update score
        mynet.update_scores(score)

#########  AMEND THE PLOTTING

#model.save('net.h5')

    #test the model
    else:
        mynet.test = model.evaluate(mygene.data, mygene.targets, batch_size=None, verbose=0)
        print(mynet.test)
        mynet.predict(mygene, model)
        print(mynet.values)
        # plot the training 
        #mynet.plot_train()
        #confusion matrix
        #mynet.values.shape
        mynet.plot_cm(mygene.classes)
    
    i += 1

# plot a confusion matrix & scatter plot

#plot_confusion_matrix(mygene_test.data, mygene_test.targets, mygene_test.classes)

#mynet.plot_scatter()
