### Binary Classification to train ML program, using the simulations generated by simulate_mark2.sh
 
# imports

import os 
import gzip
import _pickle as pickle

import numpy as np
import scipy.stats

import skimage.transform
from keras import models, layers, activations, optimizers, regularizers
from keras.utils import plot_model
from keras.models import load_model
from keras import backend as K

import matplotlib.pyplot as plt
from sklearn.metrics import confusion_matrix
import pymc3 # this will be removed
import pydot # optional
from sklearn import svm, datasets
from sklearn.model_selection import train_test_split
from sklearn.utils.multiclass import unique_labels

import itertools

import ImaGene

exec(open('/Users/nathanrobins/Documents/UG_proj/ImaGene/ImaGene.py').read())


i = 1
#create a while loop to iterate over everything
while i<=5:
	print(i)
	#read simulations & convert them into objects
	myfile = ImaFile(simulations_folder='/Users/nathanrobins/Documents/UG_proj/simdata17.05.1', nr_samples=128, model_name='Marth-3epoch-CEU')
	mygene = myfile.read_simulations(parameter_name='selection_coeff_hetero', max_nrepl=100)

	#manipulate the object
	mygene.majorminor()
	mygene.filter_freq(0.01)
	mygene.sort('rows_freq')
	mygene.sort('cols_freq')
	mygene.resize((128, 128))
	mygene.convert(verbose=True)

	# choose classes of selection
	mygene.classes = np.array([0,300])

	#plot one image/class 
	#plot only once, on first iteration
	if i ==1:
		for sel in mygene.classes:
			print(sel)
			#mygene.plot(np.where(mygene.targets == sel)[0][0])
		mygene.summary()

	#check new dimensions
	classes_idx = get_index_classes(mygene.targets, mygene.classes)
	mygene.subset(classes_idx)

	#randomly shuffle images
	rnd_idx = get_index_random(mygene)
	mygene.subset(rnd_idx)

	#vectorise targets so that they are suitable for keras
	mygene.targets = to_binary(mygene.targets)

	#save & load
	mygene.save(file='mygene')
	mygene = load_imagene(file='mygene')



	#first iteration
	if i ==1: 
	# Build the keras model
		model = models.Sequential([
                    layers.Conv2D(filters=32, kernel_size=(3,3), strides=(1,1), activation='relu', kernel_regularizer=regularizers.l1_l2(l1=0.005, l2=0.005), padding='valid', input_shape=mygene.data.shape[1:4]),
                    layers.MaxPooling2D(pool_size=(2,2)),
                    layers.Conv2D(filters=32, kernel_size=(3,3), strides=(1,1), activation='relu', kernel_regularizer=regularizers.l1_l2(l1=0.005, l2=0.005), padding='valid'),
                    layers.MaxPooling2D(pool_size=(2,2)),
                    layers.Conv2D(filters=32, kernel_size=(3,3), strides=(1,1), activation='relu', kernel_regularizer=regularizers.l1_l2(l1=0.005, l2=0.005), padding='valid'),
                    layers.MaxPooling2D(pool_size=(2,2)),
                    layers.Flatten(),
                    layers.Dense(units=64, activation='relu'),
                    layers.Dense(units=1, activation='sigmoid')])

		model.compile(optimizer='rmsprop',
			  loss='binary_crossentropy',
			  metrics=['accuracy'])   

	# intialise the network object
		mynet = ImaNet(name='[C32+P]x3+D64')

	#visualise the model
		model.summary()
#		plot_model(model, 'net.png')		

	#train the model
	if i <5:
		score = model.fit(mygene.data, mygene.targets, batch_size=32, epochs=20, verbose=1, validation_split=0.10)
		#update score
		mynet.update_scores(score)	  

	#test the model
	else:
		mynet.test = model.evaluate(mygene.data, mygene.targets, batch_size=None, verbose=1)
		print(mynet.test)
		mynet.predict(mygene, model)

        # plot a confusion matrix
		mynet.values.shape

		mynet.plot_cm(mygene.classes)

	i +=1

# WRITE A CODE TO SAVE FINAL MODEL, TESTING DATA & NETWORK) 

