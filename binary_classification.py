

### Binary Classification to train ML program, using the simulations generated by simulate.sh


 
# imports

import os 
import gzip
#import _pickle as pickle
import pickle

import numpy as np
import scipy.stats

import skimage.transform
from keras import models, layers, activations, optimizers, regularizers
from keras.utils import plot_model
from keras.models import load_model
from keras import backend as K

import matplotlib.pyplot as plt
from sklearn.metrics import confusion_matrix
import pymc3 # this will be removed
import pydot # optional

#import ImaGene

execfile('/home/nathanrobins/UG_proj/ImaGene/ImaGene.py')

# read the simulations from simulate.sh & store them into objects

# DOUBLE CHECK THE FILE & MODEL NAME
myfile = ImaFile(simulations_folder='/home/nathanrobins/UG_proj/sim_data', nr_samples=128, model_name='Marth-3epoch-CEU')

# USE A V LOW NO OF REPLICATES JUST TO CHECK THAT THE PIPELINE WORKS
mygene = myfile.read_simulations(parameter_name='selection_coeff_hetero', max_nrepl=2000)

# look at the allele frequency

mygene.summary()

#freqs = calculate_allele_frequency(mygene, ? )
## ? should be exactly where the allele of choice is
#plt.scatter(mygene.targets, freqs, marker='o')
#plt.xlabel('Target')
#plt.ylabel('Allele frequency')

# manipulate the object - INCLUDING CHANGE THE SIZE TO 128 BY 128 (DUE TO THE NUMBER OF CHROM IN SIMULATE/SH BEING 128)
mygene.majorminor()
# remove alleese with low frew = mygene.filter_freq(0.01)
mygene.sort('rows_freq')
mygene.sort('cols_freq')
mygene.resize((128, 128))
mygene.convert(verbose=True)

# plot one image / class

for sel in mygene.classes:
    print(sel)
    mygene.plot(np.where(mygene.targets == sel)[0][0])
mygene.summary()

# select 0 and 300 classes and check new dimensions
# mygene.classes = np.array([0,300])
# classes_idx = get_index_classes(mygene.targets, mygene.classes)
# len(classes_idx)

#mygene.subset(classes_idx)
#mygene.summary

# randomly shuffle the images

rnd_idx = get_index_random(mygene)
mygene.subset(rnd_idx)

# convert the targets such that they are appropiate targets for keras --> i.e. vectorise them
mygene.targets = to_binary(mygene.targets)

# data is now classification ready --> save it
mygene.save(file='mygene')

# to load:
mygene = load_imagene(file='mygene')

# Build the keras model
model = models.Sequential([
                    layers.Conv2D(filters=32, kernel_size=(3,3), strides=(1,1), activation='relu', kernel_regularizer=regularizers.l1_l2(l1=0.005, l2=0.005), padding='valid', input_shape=mygene.data.shape[1:4]),
                    layers.MaxPooling2D(pool_size=(2,2)),
                    layers.Conv2D(filters=32, kernel_size=(3,3), strides=(1,1), activation='relu', kernel_regularizer=regularizers.l1_l2(l1=0.005, l2=0.005), padding='valid'),
                    layers.MaxPooling2D(pool_size=(2,2)),
                    layers.Conv2D(filters=32, kernel_size=(3,3), strides=(1,1), activation='relu', kernel_regularizer=regularizers.l1_l2(l1=0.005, l2=0.005), padding='valid'),
                    layers.MaxPooling2D(pool_size=(2,2)),
                    layers.Flatten(),
                    layers.Dense(units=64, activation='relu'),
                    layers.Dense(units=1, activation='sigmoid')])

model.compile(optimizer='rmsprop',
			  loss='binary_crossentropy',
			  metrics=['accuracy'])                    

# summarise the model
model.summary()
plot_model(model, 'net.png')

# intialise the network object & update scores
mynet = ImaNet(name='[C32+P]x3+D64')
#mynet.update_scores(score)

#number of epochs to test
no_epochs = 20

# train the model
for x in range(no_epochs):
	score = model.fit(mygene.data, mygene.targets, batch_size=32, epochs=1, verbose=1, validation_split=0.10)
	mynet.update_scores(score)

#model.save('net.h5')

# intialise the network object & update scores
#mynet = ImaNet(name='[C32+P]x3+D64')
#mynet.update_scores(score)


#repeat the procedure for training for all iterations
#i = 2
#while i < 10:

#    print(i)
    
#    myfile = ImaFile(simulations_folder='/Users/nathanrobins/Documents/UG_proj/sim_data_output' + str(i) + '.Epoch3', nr_samples=128, model_name='Marth-3epoch-CEU')
#    mygene = myfile.read_simulations(parameter_name='selection_coeff_hetero', max_nrepl=5)

#    mygene.majorminor()
#    mygene.filter_freq(0.01)
#    mygene.sort('rows_freq')
#    mygene.sort('cols_freq')
#    mygene.resize((128, 128))
#    mygene.convert()

#    mygene.classes = np.array([0,300])
#    mygene.subset(get_index_classes(mygene.targets, mygene.classes))
#    mygene.subset(get_index_random(mygene))

#    mygene.targets = to_binary(mygene.targets)
    
    #model = load_model('net.h5')
    
#    score = model.fit(mygene.data, mygene.targets, batch_size=32, epochs=1, verbose=1, validation_split=0.10)
#    mynet.update_scores(score)
    
    #model.save('net.h5')
    
#    i += 1


# plot the training 
mynet.plot_train()

# save and/or load final model

model.save('net.h5')

model = load_model('net.h5')

# evaluate the last training on testing set

#i = 10
#myfile = ImaFile(simulations_folder='/Users/nathanrobins/Documents/UG_proj/sim_data_output' + str(i) + '.Epoch3', nr_samples=128, model_name='Marth-3epoch-CEU')
#mygene_test = myfile.read_simulations(parameter_name='selection_coeff_hetero', max_nrepl=2000)

#mygene_test.majorminor()
#mygene_test.filter_freq(0.01)
#mygene_test.sort('rows_freq')
#mygene_test.sort('cols_freq')
#mygene_test.resize((128, 128))
#mygene_test.convert()

#mygene_test.classes = np.array([0,300])
#classes_idx = get_index_classes(mygene_test.targets, mygene_test.classes)
#mygene_test.subset(classes_idx)
#rnd_idx = get_index_random(mygene_test)
#mygene_test.subset(rnd_idx)

#mygene_test.targets = to_binary(mygene_test.targets)

#mynet.test = model.evaluate(mygene_test.data, mygene_test.targets, batch_size=None, verbose=0)
#print(mynet.test)


# plot a confusion matrix & scatter plot

#mynet.predict(mygene_test, model)
#mynet.values.shape

#mynet.plot_cm(mygene_test.classes)

#mynet.plot_scatter()
